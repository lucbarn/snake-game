/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/style.scss":
/*!************************!*\
  !*** ./src/style.scss ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://snake-game/./src/style.scss?");

/***/ }),

/***/ "./src/blocks.ts":
/*!***********************!*\
  !*** ./src/blocks.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MoveBlock: () => (/* binding */ MoveBlock),\n/* harmony export */   SnakeBlock: () => (/* binding */ SnakeBlock),\n/* harmony export */   areSamePoints: () => (/* binding */ areSamePoints),\n/* harmony export */   pointToString: () => (/* binding */ pointToString)\n/* harmony export */ });\nfunction pointToString(point) {\n    const res = point\n        .map(n => n.toString())\n        .join('_');\n    return res;\n}\nfunction areSamePoints(point1, point2) {\n    const [x1, y1] = point1;\n    const [x2, y2] = point2;\n    return x1 === x2 && y1 === y2;\n}\nclass Block {\n    constructor() {\n        this.nextBlock = null;\n    }\n    getNextBlock() {\n        return this.nextBlock;\n    }\n    setNextBlock(nextBlock) {\n        this.nextBlock = nextBlock;\n    }\n}\nclass SnakeBlock extends Block {\n    constructor(position, id) {\n        super();\n        this.id = id;\n        this.nextBlock = null;\n        this.position = [...position];\n    }\n    getPosition() {\n        return this.position;\n    }\n    setPosition(position) {\n        this.position = position;\n    }\n    getId() {\n        return this.id;\n    }\n}\nclass MoveBlock extends Block {\n    constructor(moves, movementDirections) {\n        super();\n        this.moves = [...moves];\n        this.movementDirections = [...movementDirections];\n    }\n    getMovementDirection() {\n        return this.movementDirections[this.movementDirections.length - 1];\n    }\n    getMovementDirections() {\n        return this.movementDirections;\n    }\n    getLastPosition() {\n        return this.moves[this.moves.length - 1];\n    }\n    getLastPositions(n) {\n        return this.moves.slice(this.moves.length - n);\n    }\n    getAllPositions() {\n        return this.moves;\n    }\n    contains(p, n = 0) {\n        const res = this\n            .getLastPositions(n)\n            .map(point => pointToString(point))\n            .includes(pointToString(p));\n        return res;\n    }\n}\n\n\n//# sourceURL=webpack://snake-game/./src/blocks.ts?");

/***/ }),

/***/ "./src/game.ts":
/*!*********************!*\
  !*** ./src/game.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Game: () => (/* binding */ Game)\n/* harmony export */ });\n/* harmony import */ var _snake__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./snake */ \"./src/snake.ts\");\n\nclass Game {\n    constructor(gameAreaWidth, gameAreaHeight, snakeBlockSize, initialPositions) {\n        this.gameAreaWidth = gameAreaWidth;\n        this.gameAreaHeight = gameAreaHeight;\n        this.snakeBlockSize = snakeBlockSize;\n        this.initialPositions = initialPositions;\n        this.init();\n    }\n    initHTMLElements() {\n        this.gameArea = this.getHtmlElementOrFail('game-area');\n        this.startButton = this.getHtmlElementOrFail('start-button');\n        this.stopButton = this.getHtmlElementOrFail('stop-button');\n        this.newGameButton = this.getHtmlElementOrFail('new-game-button');\n        this.pointsValue = this.getHtmlElementOrFail('points-value');\n        this.gameOverLayer = this.getHtmlElementOrFail('game-over-layer');\n        this.snakeMovingTail = this.getHtmlElementOrFail('moving-tail');\n        this.snakeMovingTailContainer = this.getHtmlElementOrFail('moving-tail-container');\n        this.snakeMovingHead = this.getHtmlElementOrFail('moving-head');\n        this.snakeMovingHeadContainer = this.getHtmlElementOrFail('moving-head-container');\n        this.normalModeButton = this.getHtmlElementOrFail('normal-mode-button');\n        this.autoModeButton = this.getHtmlElementOrFail('auto-mode-button');\n    }\n    getHtmlElementOrFail(id) {\n        const element = document.getElementById(id);\n        if (element === null) {\n            throw 'Could not find element with id ' + id + '.';\n        }\n        return element;\n    }\n    init() {\n        this.initHTMLElements();\n        this.startButton.addEventListener('click', this.startGame.bind(this));\n        this.stopButton.addEventListener('click', this.stopGame.bind(this));\n        this.newGameButton.addEventListener('click', this.newGame.bind(this));\n        this.normalModeButton.addEventListener('click', this.setNormalMode.bind(this));\n        this.autoModeButton.addEventListener('click', this.setAutoMode.bind(this));\n        this.blocksMap = new Map();\n        this.nextMoves = [];\n    }\n    setNormalMode() {\n        this.autoplay = false;\n        window.addEventListener('keydown', this.getDirection.bind(this));\n        this.autoModeButton.classList.remove('blue-button');\n        this.normalModeButton.classList.add('blue-button');\n    }\n    setAutoMode() {\n        this.autoplay = true;\n        this.nextMoves = this.snake.nextMoves(this.snakeBlockSize, this.gameAreaWidth, this.gameAreaHeight, this.foodBlockPosition);\n        window.removeEventListener('keydown', this.getDirection.bind(this));\n        this.normalModeButton.classList.remove('blue-button');\n        this.autoModeButton.classList.add('blue-button');\n    }\n    newGame() {\n        this.gameStarted = false;\n        this.gameOver = false;\n        this.setPoints(0);\n        this.clearSnake();\n        this.initialPositions.forEach((coordinates, i) => this.createNewBlock(...coordinates, i));\n        this.snake = new _snake__WEBPACK_IMPORTED_MODULE_0__.Snake(this.initialPositions, this.snakeBlockSize, 'right');\n        this.snakeMovingTailContainer.style.left = this.initialPositions[0][0] + 'px';\n        this.snakeMovingTailContainer.style.top = this.initialPositions[0][1] + 'px';\n        this.snakeMovingHeadContainer.style.left = this.initialPositions[this.initialPositions.length - 1][0] + 'px';\n        this.snakeMovingHeadContainer.style.top = this.initialPositions[this.initialPositions.length - 1][1] + 'px';\n        this.createFoodBlock();\n        this.setNormalMode();\n        this.gameOverLayer.style.display = 'none';\n    }\n    startGame() {\n        if (!(this.gameOver || this.gameStarted)) {\n            this.gameStarted = true;\n            this.snakeMovement = setInterval(() => {\n                if (this.autoplay && this.nextMoves.length > 0) {\n                    const nextMove = this.nextMoves.pop();\n                    if (nextMove != undefined) {\n                        this.snake.nextMovementDirection = nextMove;\n                    }\n                }\n                switch (this.snake.nextMovementDirection) {\n                    case 'left':\n                        this.moveSnake(-this.snakeBlockSize, 0);\n                        break;\n                    case 'up':\n                        this.moveSnake(0, -this.snakeBlockSize);\n                        break;\n                    case 'right':\n                        this.moveSnake(this.snakeBlockSize, 0);\n                        break;\n                    case 'down':\n                        this.moveSnake(0, this.snakeBlockSize);\n                        break;\n                }\n            }, 50);\n        }\n    }\n    stopGame() {\n        clearInterval(this.snakeMovement);\n        this.gameStarted = false;\n    }\n    clearSnake() {\n        for (let [index, currentBlock] of this.blocksMap) {\n            this.gameArea.removeChild(currentBlock);\n        }\n        this.blocksMap.clear();\n    }\n    createNewBlock(x, y, id, isHead = false) {\n        const newBlock = document.createElement('div');\n        newBlock.classList.add('block');\n        newBlock.classList.add('snake-block');\n        newBlock.style.left = x + 'px';\n        newBlock.style.top = y + 'px';\n        this.blocksMap.set(id, newBlock);\n        if (isHead) {\n            if (this.snakeOldHead != null) {\n                this.snakeOldHead.classList.remove('transparent');\n            }\n            newBlock.classList.add('transparent');\n            this.snakeOldHead = newBlock;\n        }\n        this.gameArea.appendChild(newBlock);\n    }\n    getNewFoodPosition() {\n        let x = Math.floor(Math.random() * this.gameAreaWidth / this.snakeBlockSize) * this.snakeBlockSize;\n        let y = Math.floor(Math.random() * this.gameAreaHeight / this.snakeBlockSize) * this.snakeBlockSize;\n        // check that the food block position doesn't overlap with the position of one of the snake's blocks;\n        // if it does, find the first available position\n        if (this.snake.hasBlock([x, y])) {\n            for (let dx = 0; dx < this.gameAreaWidth; dx += this.snakeBlockSize) {\n                for (let dy = 0; dy < this.gameAreaHeight; dy += this.snakeBlockSize) {\n                    const x2 = (x + dx) % this.gameAreaWidth;\n                    const y2 = (y + dy) % this.gameAreaHeight;\n                    if (!this.snake.hasBlock([x2, y2])) {\n                        return [x2, y2];\n                    }\n                }\n            }\n            return null;\n        }\n        else {\n            return [x, y];\n        }\n    }\n    createFoodBlock() {\n        const optionalNewFoodPosition = this.getNewFoodPosition();\n        if (optionalNewFoodPosition == null) {\n            this.setGameOver();\n            return;\n        }\n        const [x, y] = optionalNewFoodPosition;\n        const newFoodBlock = document.createElement('div');\n        newFoodBlock.classList.add('block');\n        newFoodBlock.classList.add('food-block');\n        newFoodBlock.style.left = x + 'px';\n        newFoodBlock.style.top = y + 'px';\n        if (this.foodBlock) {\n            this.gameArea.removeChild(this.foodBlock);\n        }\n        this.foodBlock = newFoodBlock;\n        this.foodBlockPosition = [x, y];\n        this.gameArea.appendChild(newFoodBlock);\n    }\n    setPoints(n) {\n        this.points = n;\n        this.pointsValue.innerText = `${this.points}`;\n    }\n    animateSnake(movements, headOnly) {\n        const [xTailMovementDir, yTailMovementDir, xHeadMovementDir, yHeadMovementDir] = movements;\n        if (xHeadMovementDir === 1) {\n            this.snakeMovingHead.classList.add('head-right-movement');\n        }\n        else if (xHeadMovementDir === -1) {\n            this.snakeMovingHead.classList.add('head-left-movement');\n        }\n        else if (yHeadMovementDir === 1) {\n            this.snakeMovingHead.classList.add('head-down-movement');\n        }\n        else {\n            this.snakeMovingHead.classList.add('head-up-movement');\n        }\n        if (!headOnly) {\n            if (xTailMovementDir === 1) {\n                this.snakeMovingTail.classList.add('tail-right-movement');\n            }\n            else if (xTailMovementDir === -1) {\n                this.snakeMovingTail.classList.add('tail-left-movement');\n            }\n            else if (yTailMovementDir === 1) {\n                this.snakeMovingTail.classList.add('tail-down-movement');\n            }\n            else {\n                this.snakeMovingTail.classList.add('tail-up-movement');\n            }\n        }\n    }\n    setGameOver() {\n        this.gameOver = true;\n        this.stopGame();\n        this.gameOverLayer.style.display = 'block';\n    }\n    nextMove() {\n        this.moveSnake(this.snakeBlockSize, 0);\n    }\n    moveSnake(dx, dy) {\n        const gameState = this.snake.move(dx, dy, this.gameAreaWidth, this.gameAreaHeight, this.foodBlockPosition);\n        const { isFoodEaten, isGameOver, headId, positions, movements } = gameState;\n        const [headPosition, oldTailPosition] = positions;\n        const [headX, headY] = headPosition;\n        if (isGameOver) {\n            this.setGameOver();\n        }\n        else if (isFoodEaten) {\n            console.log('Food eaten');\n            this.createNewBlock(headX, headY, headId, true);\n            console.log('Block created');\n            this.createFoodBlock();\n            console.log('Food block created');\n            if (this.autoplay) {\n                this.nextMoves = this.snake.nextMoves(this.snakeBlockSize, this.gameAreaWidth, this.gameAreaHeight, this.foodBlockPosition);\n            }\n            this.setPoints(++this.points);\n            // empty moving head's background by removing its class\n            this.snakeMovingHead.className = '';\n            // move moving head to the new head's position\n            this.snakeMovingHeadContainer.style.left = headX + 'px';\n            this.snakeMovingHeadContainer.style.top = headY + 'px';\n            // trigger animation of head\n            this.animateSnake(movements, true);\n        }\n        else {\n            const snakeHeadDiv = this.blocksMap.get(headId);\n            if (snakeHeadDiv == undefined) {\n                throw 'Invalid state';\n            }\n            // move (empty) moving tail to the old tail's position\n            this.snakeMovingTailContainer.style.left = oldTailPosition[0] + 'px';\n            this.snakeMovingTailContainer.style.top = oldTailPosition[1] + 'px';\n            // fill moving tail's background by removing its class so that it falls back to its\n            // default style\n            this.snakeMovingTail.className = '';\n            // without offsetHeight the same animation (i.e. in the same direction)\n            // cannot be triggered more than once\n            this.snakeMovingTail.offsetHeight;\n            if (this.snakeOldHead != null) {\n                this.snakeOldHead.classList.remove('transparent');\n            }\n            snakeHeadDiv.classList.add('transparent');\n            this.snakeOldHead = snakeHeadDiv;\n            // move snake's last block to the new head position\n            snakeHeadDiv.style.left = headX + 'px';\n            snakeHeadDiv.style.top = headY + 'px';\n            // empty moving head's background by removing its class\n            this.snakeMovingHead.className = '';\n            this.snakeMovingHead.offsetHeight;\n            // move moving head to the new head's position\n            this.snakeMovingHeadContainer.style.left = headX + 'px';\n            this.snakeMovingHeadContainer.style.top = headY + 'px';\n            // trigger animation of both tail and head\n            this.animateSnake(movements, false);\n            // update snakes's movement direction\n            this.snake.movementDirection = this.snake.nextMovementDirection;\n        }\n    }\n    getDirection(event) {\n        switch (event.which) {\n            // the snake cannot invert its course\n            case 37:\n                if (this.snake.movementDirection !== 'right') {\n                    this.snake.nextMovementDirection = 'left';\n                }\n                break;\n            case 38:\n                if (this.snake.movementDirection !== 'down') {\n                    this.snake.nextMovementDirection = 'up';\n                }\n                break;\n            case 39:\n                if (this.snake.movementDirection !== 'left') {\n                    this.snake.nextMovementDirection = 'right';\n                }\n                break;\n            case 40:\n                if (this.snake.movementDirection !== 'up') {\n                    this.snake.nextMovementDirection = 'down';\n                }\n                break;\n        }\n    }\n}\n\n\n//# sourceURL=webpack://snake-game/./src/game.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _style_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style.scss */ \"./src/style.scss\");\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./game */ \"./src/game.ts\");\n\n\nconst gameAreaWidth = 900;\nconst gameAreaHeight = 600;\nconst snakeBlockSize = 15;\nconst initialPositions = [[0, 0], [snakeBlockSize, 0], [2 * snakeBlockSize, 0]];\nconst game = new _game__WEBPACK_IMPORTED_MODULE_1__.Game(gameAreaWidth, gameAreaHeight, snakeBlockSize, initialPositions);\ngame.init();\ngame.newGame();\n\n\n//# sourceURL=webpack://snake-game/./src/main.ts?");

/***/ }),

/***/ "./src/snake.ts":
/*!**********************!*\
  !*** ./src/snake.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Snake: () => (/* binding */ Snake)\n/* harmony export */ });\n/* harmony import */ var _blocks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./blocks */ \"./src/blocks.ts\");\n\nclass Snake {\n    constructor(initialPositions, blockSize, movementDirection) {\n        if (initialPositions.length == 0) {\n            throw 'At least an initial block is needed to create the snake';\n        }\n        const blocks = initialPositions.map((position, i) => new _blocks__WEBPACK_IMPORTED_MODULE_0__.SnakeBlock(position, i));\n        // the list's head represents the tail of the snake\n        this.snakeTail = blocks[0];\n        // join the nodes of the linked list\n        for (let i = 1; i < blocks.length; i++) {\n            blocks[i - 1].setNextBlock(blocks[i]);\n        }\n        // the list's tail represents the head of the snake\n        this.snakeHead = blocks[blocks.length - 1];\n        this.blocksSet = new Set(initialPositions.map(position => (0,_blocks__WEBPACK_IMPORTED_MODULE_0__.pointToString)(position)));\n        this.lastId = blocks.length - 1;\n        this.blocksNum = blocks.length;\n        this.movementDirection = movementDirection;\n        this.nextMovementDirection = movementDirection;\n        this.blockSize = blockSize;\n    }\n    move(dx, dy, gameAreaWidth, gameAreaHeight, foodBlockPosition) {\n        let foodBlockEaten = false;\n        let gameOver = false;\n        const [headX, headY] = this.snakeHead.getPosition();\n        const newHeadPosition = [\n            (gameAreaWidth + headX + dx) % gameAreaWidth,\n            (gameAreaHeight + headY + dy) % gameAreaHeight\n        ];\n        const oldTailPosition = this.snakeTail.getPosition();\n        let xTailMovementDir = 0;\n        let yTailMovementDir = 0;\n        let xHeadMovementDir = 0;\n        let yHeadMovementDir = 0;\n        // if the snake eats the food block, a new block is created\n        if (newHeadPosition[0] === foodBlockPosition[0]\n            && newHeadPosition[1] === foodBlockPosition[1]) {\n            console.log('hit');\n            const newHead = new _blocks__WEBPACK_IMPORTED_MODULE_0__.SnakeBlock(newHeadPosition, ++this.lastId);\n            this.blocksSet.add((0,_blocks__WEBPACK_IMPORTED_MODULE_0__.pointToString)(newHeadPosition));\n            this.snakeHead.setNextBlock(newHead);\n            this.snakeHead = newHead;\n            foodBlockEaten = true;\n            this.blocksNum++;\n            console.log('Hit end');\n            // if the snake doesn't eat the food block, the block on the tail is moved\n            // to the head's position\n        }\n        else {\n            const newHead = this.snakeTail;\n            this.blocksSet.delete((0,_blocks__WEBPACK_IMPORTED_MODULE_0__.pointToString)(oldTailPosition));\n            const newTail = this.snakeTail.getNextBlock();\n            if (newTail === null) {\n                throw 'Invalid snake blocks';\n            }\n            this.snakeTail = newTail;\n            this.snakeHead.setNextBlock(newHead);\n            this.snakeHead = newHead;\n            this.snakeHead.setNextBlock(null);\n            this.snakeHead.setPosition(newHeadPosition);\n            this.blocksSet.add((0,_blocks__WEBPACK_IMPORTED_MODULE_0__.pointToString)(newHeadPosition));\n            if (oldTailPosition[0] === this.snakeTail.getPosition()[0]) {\n                // compute vertical animation for moving tail\n                yTailMovementDir = ((oldTailPosition[1] + this.blockSize) % gameAreaHeight === this.snakeTail.getPosition()[1]) ? 1 : -1;\n            }\n            else {\n                // compute horizontal animation for moving tail\n                xTailMovementDir = ((oldTailPosition[0] + this.blockSize) % gameAreaWidth === this.snakeTail.getPosition()[0]) ? 1 : -1;\n            }\n        }\n        if (dx === 0) {\n            // compute vertical animation for moving head\n            yHeadMovementDir = (dy > 0) ? 1 : -1;\n        }\n        else {\n            // compute horizontal animation for moving head\n            xHeadMovementDir = (dx > 0) ? 1 : -1;\n        }\n        // If two blocks overlap, the game is over\n        if (this.blocksSet.size < this.blocksNum) {\n            gameOver = true;\n        }\n        const gameState = {\n            isFoodEaten: foodBlockEaten,\n            isGameOver: gameOver,\n            headId: this.snakeHead.getId(),\n            positions: [this.snakeHead.getPosition(), oldTailPosition],\n            movements: [xTailMovementDir, yTailMovementDir, xHeadMovementDir, yHeadMovementDir]\n        };\n        return gameState;\n    }\n    hasBlock(block) {\n        return this.blocksSet.has((0,_blocks__WEBPACK_IMPORTED_MODULE_0__.pointToString)(block));\n    }\n    nextMoves(snakeBlockSize, areaWidth, areaHeight, foodBlockPosition) {\n        let moves = [];\n        let current = this.snakeTail;\n        while (current !== null) {\n            moves.push(current.getPosition());\n            current = current.getNextBlock();\n        }\n        console.log('ok 1');\n        let head = new _blocks__WEBPACK_IMPORTED_MODULE_0__.MoveBlock(moves, [this.movementDirection]);\n        let tail = head;\n        let firstMove;\n        let secondMove;\n        let thirdMove;\n        const visited = new Set([(0,_blocks__WEBPACK_IMPORTED_MODULE_0__.pointToString)(head.getLastPosition())]);\n        while (true) {\n            const [x, y] = head.getLastPosition();\n            if (head.getMovementDirection() === 'up') {\n                firstMove = {\n                    p: [x, (y - snakeBlockSize + areaHeight) % areaHeight],\n                    dir: 'up'\n                };\n                secondMove = {\n                    p: [(x - snakeBlockSize + areaWidth) % areaWidth, y],\n                    dir: 'left'\n                };\n                thirdMove = {\n                    p: [(x + snakeBlockSize + areaWidth) % areaWidth, y],\n                    dir: 'right'\n                };\n            }\n            else if (head.getMovementDirection() === 'right') {\n                firstMove = {\n                    p: [(x + snakeBlockSize + areaWidth) % areaWidth, y],\n                    dir: 'right'\n                };\n                secondMove = {\n                    p: [x, (y - snakeBlockSize + areaHeight) % areaHeight],\n                    dir: 'up'\n                };\n                thirdMove = {\n                    p: [x, (y + snakeBlockSize + areaHeight) % areaHeight],\n                    dir: 'down'\n                };\n            }\n            else if (head.getMovementDirection() === 'down') {\n                firstMove = {\n                    p: [x, (y + snakeBlockSize + areaHeight) % areaHeight],\n                    dir: 'down'\n                };\n                secondMove = {\n                    p: [(x - snakeBlockSize + areaWidth) % areaWidth, y],\n                    dir: 'left'\n                };\n                thirdMove = {\n                    p: [(x + snakeBlockSize + areaWidth) % areaWidth, y],\n                    dir: 'right'\n                };\n            }\n            else {\n                firstMove = {\n                    p: [(x - snakeBlockSize + areaWidth) % areaWidth, y],\n                    dir: 'left'\n                };\n                secondMove = {\n                    p: [x, (y - snakeBlockSize + areaHeight) % areaHeight],\n                    dir: 'up'\n                };\n                thirdMove = {\n                    p: [x, (y + snakeBlockSize + areaHeight) % areaHeight],\n                    dir: 'down'\n                };\n            }\n            let newPos;\n            let newDir;\n            if (!visited.has((0,_blocks__WEBPACK_IMPORTED_MODULE_0__.pointToString)(firstMove['p'])) && !head.contains(firstMove['p'], this.blocksNum)) {\n                newPos = firstMove['p'];\n                newDir = firstMove['dir'];\n                const isFoodBlockFound = (0,_blocks__WEBPACK_IMPORTED_MODULE_0__.areSamePoints)(newPos, foodBlockPosition);\n                if (isFoodBlockFound) {\n                    return head.getMovementDirections().slice(1).concat([newDir]).reverse();\n                }\n                const nextBlock = new _blocks__WEBPACK_IMPORTED_MODULE_0__.MoveBlock(head.getAllPositions().concat([newPos]), head.getMovementDirections().concat([newDir]));\n                tail.setNextBlock(nextBlock);\n                tail = nextBlock;\n                visited.add((0,_blocks__WEBPACK_IMPORTED_MODULE_0__.pointToString)(newPos));\n            }\n            if (!visited.has((0,_blocks__WEBPACK_IMPORTED_MODULE_0__.pointToString)(secondMove['p'])) && !head.contains(secondMove['p'], this.blocksNum)) {\n                newPos = secondMove['p'];\n                newDir = secondMove['dir'];\n                const isFoodBlockFound = (0,_blocks__WEBPACK_IMPORTED_MODULE_0__.areSamePoints)(newPos, foodBlockPosition);\n                if (isFoodBlockFound) {\n                    return head.getMovementDirections().slice(1).concat([newDir]).reverse();\n                }\n                const nextBlock = new _blocks__WEBPACK_IMPORTED_MODULE_0__.MoveBlock(head.getAllPositions().concat([newPos]), head.getMovementDirections().concat([newDir]));\n                tail.setNextBlock(nextBlock);\n                tail = nextBlock;\n                visited.add((0,_blocks__WEBPACK_IMPORTED_MODULE_0__.pointToString)(newPos));\n            }\n            if (!visited.has((0,_blocks__WEBPACK_IMPORTED_MODULE_0__.pointToString)(thirdMove['p'])) && !head.contains(thirdMove['p'], this.blocksNum)) {\n                newPos = thirdMove['p'];\n                newDir = thirdMove['dir'];\n                const isFoodBlockFound = (0,_blocks__WEBPACK_IMPORTED_MODULE_0__.areSamePoints)(newPos, foodBlockPosition);\n                if (isFoodBlockFound) {\n                    return head.getMovementDirections().slice(1).concat([newDir]).reverse();\n                }\n                const nextBlock = new _blocks__WEBPACK_IMPORTED_MODULE_0__.MoveBlock(head.getAllPositions().concat([newPos]), head.getMovementDirections().concat([newDir]));\n                tail.setNextBlock(nextBlock);\n                tail = nextBlock;\n                visited.add((0,_blocks__WEBPACK_IMPORTED_MODULE_0__.pointToString)(newPos));\n            }\n            const headNextBlock = head.getNextBlock();\n            if (headNextBlock === null) {\n                break;\n            }\n            else {\n                head = headNextBlock;\n            }\n        }\n        return head.getMovementDirections().slice(1).reverse();\n    }\n}\n\n\n//# sourceURL=webpack://snake-game/./src/snake.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;